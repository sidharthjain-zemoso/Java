 The functions we have seen so far work only with reference types. The functions are expecting classes, not primitives such as int or Boolean or double or long. Say we have a predicate to find an even number. This even number predicate is expecting an integer returning a Boolean value. The type it's expecting here is a reference type a capital Integer. That is an integer class, not a primitive type like I-N-T, int. When we invoke dysfunction, we are providing a primitive int, for example. As you can see, the testPredicate method is invoked with a simple integer number. We are using a primitive int here. The predicate what we are trying to use is taking an integer that is a boxed up integer. However, behind the scenes, the compiler is converting the primitive int to an integer object. So if you recall, this process of converting primitives to reference types is called boxing. Boxing operation is a tad bit heavy on the performance scale. The objects will be created on the heap, which may well add to the memory of your application. If you know that we are passing an int rather than an integer, then we wish to create a lambda expression on primitive ints. If we know that we are passing an int, and wish to create a lambda expression on primitive ints, we can abandon the predicate and start using a specialized function called IntPredicate. This function is used when we are working with primitive integers. The semantics are exactly the same as predicate function including the static and default methods as exposed by the predicate function. Look at the Java doc of this IntPredicate. The test method is picking up the primitive int. First thing you may have noticed is that we have dropped the genetics in the equation. The interface is not a genetic type. The name itself gives us the clue that predicate takes only primitive integers. Rest of the usage is exactly the same as normal a predicate. Going with the same flow, we can also have a predicate for double and long primitives too. They're called DoublePredicate and LongPredicate. So if you have a predicate taking in a double value, we don't have to pass in that as a reference type. Instead, we could simply use DoublePredicate, which takes in a primitive double. And so is a long. So use the LongPredicate just like this. So LongPredicate, DoublePredicate, or IntPredicate. So the primitive functions doesn't stop with predicates. There are similar specializations available on other functions too. For example, IntConsumer is a specialization of the consumer function for the primitive ints. So is a DoubleConsumer for primitive doubles and LongConsumer for primitive longs. It is very easy to understand these variants. Supplier variants do exactly the same story. IntSupplier returns a primitive integer as return value, but LongSupplier a primitive long value and DoubleSupplier a primitive double value. Nothing should surprise us here. So when it comes to function specializations, they are exactly the same as well. We take a break here and continue learning the function specializations in the next session.

 BiPredicate, BiConsumer, BiSupplier, and BiFunction. As the names suggest, they all work on two arguments passed in.
