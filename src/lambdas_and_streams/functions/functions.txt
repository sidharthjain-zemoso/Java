 Many times, we may have a recurring functionality being added to our application. For example, checking if a movie falls in the classics category, or if an airplane bound to Paris, is it on schedule or not, or sending out an email notification once a customer places an order, or perhaps mapping out an insurance number to apply. If you take a step back, what's really happening here is that we are checking for a valid condition for transforming one type to another type, or consuming an input for some internal processing, or sometimes publishing a response for an inbound request based on some conditions. Normally what we do in Java is, we design these features using interfaces. Let's see an interface for checking a movie, if it's a classic movie or not. This interface provides a method to check if a movie is classic or not. All it is doing is taking an ID and returning as a true or false value. In the similar lines, if you need to find out if a person is an employee or not given an employee ID, we design that functionality using this interface-- or maybe admitting a patient into a hospital. Look at the first two interfaces closely. These interfaces and the features they are supporting, you can infer a common strategy repeating itself. Given a value, return a Boolean expression. So given an ID, they check for a condition and return true or false. Instead of creating set of interfaces for each and every case or type, wouldn't it be better if you have generalized interfaces that would be used irrespective of the use case? For example, something like this-- this interface satisfies both movie and person. The reason for that is that we are passing a type T. So given the type T, it's going to do some test and passes the return value as Boolean back to you. Well, this is what exactly Java 8 has done for us. The designers have created a set of commonly used functional interfaces for us to start using them off the shelf, out of the box. For example, the functionality of testing for a valid condition is defined in a predicate interface. Predicate has a method called test to check for a condition, and returns the Boolean value based on the conditions result. So the definition of predicate has just become like this. Similar to testing a functionality, there are other common use cases as well, such as consuming data, mapping a data point to another, transforming one type of another, as we've seen earlier. So Java introduced a set of new functions for supporting these type of functionalities. These are the recurring use cases. And for each recurring use case, they have created a new function. So along with predicate, other interfaces such as consumer function, and supplier, and many specific variants of these interfaces were created. We usually call this library as functions library. A new package called java.util.function was created to house these new functions. So in the next few sessions, we will learn about these new functions in detail.

 Predicate is a functional interface provided by the Java 8 functions library whose sole aim is to evaluate a condition and return true or false to the client.

 Java 8 provides an out-of-box function for accepting an input and returning nothing. This is called consumer functional interface. Any functionality that consumes input arguments but produces no output is fit for consumer as this functional interface. Consumer functional interface is a generic interface that has single abstract method accept.

 Supplier function supplies us with results, supplies us with the data. It's exactly opposite the consumer in that it doesn't take any input arguments, but returns data out. The definition of the Supplier interface looks like this. It is a generic interface with one method GET which has no input arguments, but returns the same type of object back. We may have situations like loading list of employees in our application cache, or maybe fetching newly created trades, or simply getting some default configurational values of a customer into our application. Such requirements are well-suited with Supplier as the function

 The function interface is used where, given an input, we expect a result in return. For example, given an employee ID, we wish to fetch an employee, or transforming the input document to produce a new object, or perhaps searching for a specific object from a list of data. The function interface definition is like this. The interface has one single abstract method called apply, which takes in a type of and T returns type of R, which is what the generic functional interface is defined here. So given an object T, we expect to receive an object of type R. The single abstract method apply applies this function to the input argument to produce the expected result of type R.

