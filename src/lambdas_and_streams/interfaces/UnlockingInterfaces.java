package lambdas_and_streams.interfaces;

public class UnlockingInterfaces {
}


/*
* The amazing thing about Java 8 is that the interface is reborn. The interface definitions are really spiced up. In this video, we briefly run through the changes brought in Java 8 related to these interfaces. One of the biggest strengths of Java 8 is backward compatibility. Java excelled and exceeded expectations in this area of source and binary compatibility compared to its peers. This has been a great strength, but at the same time, it has caused a great pain, too. As you know, the interface is the mother of any user library. Designers start building frameworks, or libraries, starting with a simple interface, weaving it with others and building the system as they go along. The backward compatibility is at heart to the Java designers. That means if we wish to modify an existing interface by adding a new method or changing the signature of an existing method, it would automatically fail with the earlier version compilers if the backward compatibility is not maintained. This posed a great threat and headache to Java designers. Most of our libraries were designed ages back, and should they need modifications, the backward compatibility will be thrown out of the window. The enhancements can only be done at the cost of communities [INAUDIBLE]. At the same time, Java 8 is embracing functional programming style too, by introducing lambda expressions. It would be a real shame if the existing libraries can't be upgraded to use the lambda expressions. Java 8 brought in an excellent solution. The interface structure is unlocked. You can add or delete new or existing methods, modify or enhance existing methods. Compiler will not be angry if you do so. This is one of the best achievements of Java 8, the interface unlocking. So what have they done to our good old grandpa interface? Well, firstly, they created a bit of a classification in them, a normal interface and a functional interface to begin with. A normal interface is something that we have been working all along, but with a twist. You can now add concrete methods to these interfaces. A proper, full implementation can be provided in an interface straight away, as we used to do in our abstract classes, for providing default implementations to some methods. The methods defined and declared in an interface with full implementation are default and starting with this. We will learn about them in due course. Staying on track, the functional interface has been surfaced for a special purpose-- to act as a target type of the lambda expression. It's a normal interface, but with, again, a twist. It can't have more than one abstract method declared in it. All lambda expressions need functional interfaces as their target types. Remember, a lambda expression is passed to a method, but only a functional interface is expected. And a functional interface is an interface with one and only one abstract method. So in all these changes around our mighty interface, there is also intersection type introduced in Java 8. In the coming lessons, we are going to learn all these new features around interfaces in detail.  */