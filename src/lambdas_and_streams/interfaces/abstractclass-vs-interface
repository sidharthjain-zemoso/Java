 If we need to provide a partial implementation of a functionality or a certain behavior, we normally follow a abstract class strategy. That is, we provide an abstract class with some methods fully defined, while leaving others to be implemented by its subclass. Since Java 8, interfaces were revamped. They were overhauled. They can consist of default methods which are nothing but full blown code implementation of a functionality similar to a method defined in an abstract class. So obviously, a question may arise in your minds. Do we need abstract classes, as we have interfaces serving the same purpose? Well, in this lesson, we look at the reason why and where the abstract classes are used and discuss the strategy why they should be used in some situation as opposed to interfaces. So let's look at both abstract classes and interfaces from a very high ground. Both of them have one thing in common-- they cannot be instantiated. Any behavior we define in them can only be inherited or derived by other classes or interfaces. Their sole purpose is to be used by other classes. Hence, they are very good candidates for implementing common behavior patterns. The fundamental difference is the way the fields and methods are structured and accessed in both. Java 8 has added the new default methods-- which were earlier defined in an abstract class are now paving their way into interfaces. Although abstract classes and interfaces may serve similar purpose, there are finer points they differ in. Abstract classes may have instance fields, for example, that may or may not be static and final. That is, the fields can be public or protected or private. And also, they can be static and final, as well. This is in contrast to what interface fields are. Interface fields are always public, static, and final, implicitly. So when do we use them? If our requirement is to share a common functionality within a set of related class structures, perhaps abstract class strategy is the best. If you would like your subclasses to inherit state in addition to behavior, extend them with relevant abstract classes. We also have a free hand in declaring the access modifiers on fields and methods. That is, we can have a public or a private or static or a non-final methods and fields, according to our class design. But if our intention is to provide behavior derived from multiple types, we should start using interface strategy. We can implement as many interfaces as we wish. Sometimes, if we wish to merge various functionalities or derive from different set of interfaces, then interface strategy is advised. Remember, we are inheriting behavior using interface default methods only. So to wrap up, don't feel obligated to use or not to use abstract classes or interfaces in your project. For me, if a state is to be inherited, I will stick to an abstract class, while if reusing behavior tops my list, then I will go with interface strategy.