 In this session, we look at that iteration strategies employed on collections and streams. We walk through the pros and cons in using these implicit and explicit iteration strategies. While working with collections, users must use external iterations to work with elements. We must use iterate to browse through the elements, apply business logic, and move forward. For example, see the call which implies external iteration here-- so here, we have to browse through all the movies, find out if this particular movie is a classic movie or not, and if it is, then add to the Top Two Classics collection. The code is doing two things. It is running through the list of elements one by one, and then applying the logic what we are asking it to do. This is two things in total, how to do, and what to do. The how part is how to browse through the collection, while the what part is to deal with what exactly the business logic we must be needing to do it for satisfying this requirement. Combining the how and what bits leads to a [INAUDIBLE] and ugly design. The code is bulky, at times, unreadable. And changing behaviors can't be [INAUDIBLE] without having to duplicate the code. This is where the advantage of streams kick in. Java developers cleverly taken a way of how to do part, and instead let us concentrate on just the logic that needs to be applied-- so see here, another example of using an internal iteration via streams. So here, we have created a stream of movies and filtered it using a condition, if it's a classic, then move forward. We also picked up the name of the movie rather than picking up the whole movie detail. Ultimately, we are printing it out to the console. Can you see anywhere we are iterating or running through the data elements present in this movies list? We don't show that iteration here. The invocation of stream method on the list is doing this for us, while we are having to worry about rest of the things, but not getting hands dirty with the iteration methodology. Also, did you notice, we didn't specify any intermediate storage variables when working with streams? See the external version example here. Here we have a top2Classics storage variable sitting there for storage purposes. Should we have a million movies in our list, can we parallelize the code and increase the performance? Unfortunately, the external strategy needs a lot mending. It needs to be refactored to remove intermediate storage variables and splice the job into individual tasks so it can be distributed to other codes and then aggregate. We can use the Java service for conjoined framework for satisfying such distributed strategy. How it work? For conjoin is not simple and easy-- it has a steep learning curve. Just a flick of a button switches on and off the light. Changing the method name from stream to parallel stream does the trick of moving the serial working code to the parallel version. It is the underlying library that can deal with the headache of slicing and dicing this particular job, so we don't have to worry about anything else but logic. In the non-stream external iteration strategy, all the elements must be browsed through to get to the result, what we are looking for. Say if there are one million elements and if you want to find out a particular classic movie strategy, we need to run through all the million movies to get to the answer. Let's put some print statements in our example to see if this is what is happening in the external iteration world. As you can see, the extended iteration has gone through all the list of elements before finding out what are the classics. Let's see the same thing for internal iteration, whether it behaves the same way. I like to imagine what happens if you have a list of one million movies for finding out two top classic movies. On the contrary, the internal iteration stream version may provide a slight advantage here. We can limit the possibilities of adding another pipeline operation called limit. We don't have to run through the whole million items to find out two. Instead, the first two elements which may have found out in the first 100,000 movies stop the pipeline operation and produce a result. Let's see how we can do that one here. Less limit to two classics. We'll stop the print statements here. As you can see, we have produced two top classics using limit functionality. The limit operator simply cuts the iteration once the condition is satisfied rather than running through the whole list. The internal iteration certainly wins our hearts due to its capabilities to provide a parallel version with much ease and elegance.